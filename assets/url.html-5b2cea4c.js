import{_ as l,p,q as i,a1 as t}from"./framework-5866ffd3.js";const o={},e=t('<h1 id="浏览器输入url" tabindex="-1"><a class="header-anchor" href="#浏览器输入url" aria-hidden="true">#</a> 浏览器输入URL</h1><ol><li><p>域名解析</p><p>把URL包含的一些信息解析出来</p><p>浏览器接收到URL后，这一个URL的结构一般是：</p><p>Protocal://Host:Port/Path?Query#Fragment</p><ul><li>Protocal：协议</li><li>Host：主机域名/IP</li><li>Port：端口号</li><li>Path：目录路径，可能是服务器上某个目录/文件地址</li><li>Query：查询参数</li><li>Fragment：前端路径、锚点等</li></ul></li><li><p>发起请求</p><p>如果是一个HTTP请求，需要建立一个网络请求线程</p><ul><li><p>DNS解析</p><p>客户端向服务器端发请求，需要根据IP地址进行通信，所以需要先找到目标服务器端IP</p><p>先从浏览器的DNS的缓存中查看是否有目标服务器的IP地址，如果没有，就从系统DNS缓存中找，如果还没有，就从hosts文件里面找，找不到就报错</p></li><li><p>TCP连接</p><p>客户端和服务器端建立TCP连接，需要进行“三次握手”：</p><ol><li>客户端向服务器端发送一个报文，包含一些信息，可以看作一个“暗号” —— 客户端请求连接待确认</li><li>服务器端接收到这个报文，知道有客户端希望建立连接并等待应答，它拿到“暗号”，然后自己也创建一个新“暗号”，然后把这些信息返给客户端 —— 服务器端请求连接待确认</li><li>客户端拿到报文，发现里面有自己发给服务端的“暗号”，确认是对应的服务器，然后也拿到服务器的“暗号”，就再把服务器的这个暗号再发给服务器端</li><li>服务器端拿到客户端的报文，发现有自己发送过去的“暗号”，所以现在双方确认过彼此，就可以建立连接了</li></ol><p>客户端和服务器端断开连接的时候，需要进行“四次握手”：</p><ol><li>客户端向服务器端发送断开连接的请求</li><li>服务器端收到后给到客户端应答，让客户端等一下，因为这个时候可能还有没完成的资源下载之类的</li><li>服务器这边资源下载完成，没啥事了，就再给客户端一个应答，告诉客户端可以断开连接了，如果客户端没有确认，会一直发送</li><li>客户端收到后，需要再次发送确认断开的请求，如果服务器端没有收到，会在一段时间后断开连接</li></ol></li></ul></li><li><p>请求</p><p>一般会用到缓存，缓存有两种：强缓存和协商缓存</p><ul><li><p>强缓存：先看浏览器本地缓存是否过期，未过期则直接用200，不需要发请求了；过期了则向服务器端请求资源</p></li><li><p>协商缓存：</p><ol><li><p>浏览器是否有缓存</p><p>1.1 没有 -&gt; 请求服务器资源</p><p>1.2 有 -&gt; 查看缓存是否过期</p><ul><li><p>1.2.1 本地缓存没有过期，则直接用</p></li><li><p>1.2.2 已经过期，则向服务器询问资源是否有修改</p></li><li><p>1.2.2.1 如果没有修改，则还是用缓存304</p></li><li><p>1.2.2.2 有修改，则返回新的资源，并存到缓存中</p></li></ul></li><li><p>拿到资源后，加载页面</p></li></ol><p>一般强缓存优于协商缓存，强缓存生效则用强缓存，否则用协商缓存，如果都不生效，则向服务器端请求资源</p></li></ul></li><li><p>网页加载</p><p>整体流程：HTML + CSS -&gt; DOM + CSSOM -&gt; 渲染树 -&gt; 开始渲染 -&gt; “盒模型” -&gt; 开始绘制 -&gt; 页面</p><p>详细：</p><p>拿到HTML + CSS + JS等文件后，需要加载页面</p><p>HTML -&gt; 词法分析、语法分析。。。 -&gt; DOM树</p><p>CSS -&gt; ... -&gt; CSSOM树</p><p>CSSOM + DOM -&gt; 渲染树：遍历DOM树节点，给每个子节点找到对应的CSS的规则</p><p>CSSOM（层叠样式表对象模型），DOM（文档对象模型）</p><p>拿到渲染树后，开始渲染，需要计算DOM节点的大小和位置，这时候计算出来一个“盒模型”</p><p>然后开始绘制，就是把节点绘制成对应的像素</p></li></ol>',2),r=[e];function a(S,c){return p(),i("div",null,r)}const u=l(o,[["render",a],["__file","url.html.vue"]]);export{u as default};
