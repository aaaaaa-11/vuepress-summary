import{_ as a,p as s,q as n,a1 as t}from"./framework-5866ffd3.js";const e={},c=t(`<h1 id="js垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#js垃圾回收机制" aria-hidden="true">#</a> JS垃圾回收机制</h1><p>目的：清除不再使用的对象，释放所占用的内存</p><p>策略：1. 引用计数法；2. 清除计数法</p><h2 id="_1-引用计数法" tabindex="-1"><a class="header-anchor" href="#_1-引用计数法" aria-hidden="true">#</a> 1. 引用计数法</h2><h3 id="_1-1-定义" tabindex="-1"><a class="header-anchor" href="#_1-1-定义" aria-hidden="true">#</a> 1.1 定义</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c61d744b-6bec-4b29-aca1-7ef89a281835/截屏2023-02-12_下午5.46.55.png" alt="截屏2023-02-12 下午5.46.55.png"></p><p>对象被引用→ 引用数++</p><p>对象被取消引用 → 引用数--</p><p>对象引用数=0 → 垃圾回收</p><h3 id="_1-2-缺陷-两对象循环引用-引用数不为0-无法回收" tabindex="-1"><a class="header-anchor" href="#_1-2-缺陷-两对象循环引用-引用数不为0-无法回收" aria-hidden="true">#</a> 1.2 缺陷： 两对象循环引用，引用数不为0，无法回收</h3><div class="language-jsx line-numbers-mode" data-ext="jsx"><pre class="language-jsx"><code><span class="token keyword">function</span> <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
	o1<span class="token punctuation">.</span>a <span class="token operator">=</span> o2
	o2<span class="token punctuation">.</span>a <span class="token operator">=</span> o1
<span class="token punctuation">}</span>
<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_2-标记清除法" tabindex="-1"><a class="header-anchor" href="#_2-标记清除法" aria-hidden="true">#</a> 2. 标记清除法</h2><h3 id="_2-1-定义" tabindex="-1"><a class="header-anchor" href="#_2-1-定义" aria-hidden="true">#</a> 2.1 定义</h3><ol><li><p>先将所有对象标记为0</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a00aacbb-c7c0-40d3-a72f-7c75cf1fedb2/截屏2023-02-12_下午5.53.15.png" alt="截屏2023-02-12 下午5.53.15.png"></p></li><li><p>从根对象开始遍历，将可获得对象标记为1，然后清除标记为0的对象</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f24f6bdf-89c2-4ec6-945b-7c8f77728d09/截屏2023-02-12_下午5.53.50.png" alt="截屏2023-02-12 下午5.53.50.png"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/698aeca3-048c-440c-a1db-6f257e3adb88/截屏2023-02-12_下午5.56.20.png" alt="截屏2023-02-12 下午5.56.20.png"></p></li><li><p>将这些对象重新标记为0，方便下次回收机制回收</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c8662790-b2ad-436d-811a-0e694d7b9b7b/截屏2023-02-12_下午5.58.43.png" alt="截屏2023-02-12 下午5.58.43.png"></p></li></ol><p>产生的问题：回收内存后，对象的位置不连续，如果有新对象进来，需要找位置</p><h3 id="_2-2-找位置" tabindex="-1"><a class="header-anchor" href="#_2-2-找位置" aria-hidden="true">#</a> 2.2 找位置</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8cc6377c-eb0b-4d0f-a49c-6e8a7cbc5f80/截屏2023-02-12_下午6.02.29.png" alt="截屏2023-02-12 下午6.02.29.png"></p><p>方法：</p><ol><li>First-fit：找到第一个能放下新对象的位置（性能最好，最常用）</li><li>Best-fit：找到能放置新对象的最小块</li><li>Worst-fit：找到最大的块，切一块空间给新对象（会产生更多的不连续的空间）</li></ol><h2 id="_3-v8对js垃圾回收机制的优化" tabindex="-1"><a class="header-anchor" href="#_3-v8对js垃圾回收机制的优化" aria-hidden="true">#</a> 3. V8对JS垃圾回收机制的优化</h2><p>对象分为：</p><ul><li>新生代（频繁回收）</li><li>老生代（不频繁回收）</li></ul><h3 id="_3-1-优化标记算法" tabindex="-1"><a class="header-anchor" href="#_3-1-优化标记算法" aria-hidden="true">#</a> 3.1 优化标记算法</h3><ol><li><p>在堆内存中开辟两块区域：</p><ul><li>新生代区域，存放新的、小的、存活时间短的对象 <ul><li>from空间：使用空间（有对象占用）</li><li>to空间：闲置空间</li></ul></li><li>老生代区域，存放老的、大的、存活时间长的对象</li></ul><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0b5b8227-0395-4767-aab2-4a6bf0ab7065/截屏2023-02-12_下午6.12.38.png" alt="截屏2023-02-12 下午6.12.38.png"></p></li><li><p>新生代垃圾回收机制：</p></li></ol><p>from空间中要占满时，标记对象 → 将存活的对象复制到to空间，清除from空间 → 交换两空间名称</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ae42cd41-31dd-4b2a-abec-0d0e7e1b2111/截屏2023-02-12_下午6.15.14.png" alt="截屏2023-02-12 下午6.15.14.png"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/bac3ac96-a032-418f-854d-c2ac2ff32e79/截屏2023-02-12_下午6.16.01.png" alt="截屏2023-02-12 下午6.16.01.png"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e653ff93-4139-4584-bfd1-9fcf7da1379f/截屏2023-02-12_下午6.17.07.png" alt="截屏2023-02-12 下午6.17.07.png"></p><ol><li><p>老生代垃圾回收机制：标记清除算法+标记压缩算法</p><p>对象标记 → 清除标记为1的对象 → 整合位置（标记压缩算法）</p></li></ol><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3ed7815a-1120-4755-a692-b2009a594bc4/截屏2023-02-12_下午6.21.06.png" alt="截屏2023-02-12 下午6.21.06.png"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/92fd621f-916f-4780-8b59-534dd644d016/截屏2023-02-12_下午6.21.18.png" alt="截屏2023-02-12 下午6.21.18.png"></p><h3 id="_3-2-多线程并行回收机制" tabindex="-1"><a class="header-anchor" href="#_3-2-多线程并行回收机制" aria-hidden="true">#</a> 3.2 多线程并行回收机制</h3><p>js是单线程语言，当执行垃圾回收机制时，会暂停，称为全停顿</p><p>优化：v8机制使得垃圾回收机制可以多线程并行执行</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35fc0c4a-7528-44fe-ab28-4c16c1ca2e72/截屏2023-02-12_下午6.26.15.png" alt="截屏2023-02-12 下午6.26.15.png"></p><p>缺点：阻塞JS执行</p><h3 id="_3-3-增量标记" tabindex="-1"><a class="header-anchor" href="#_3-3-增量标记" aria-hidden="true">#</a> 3.3 增量标记</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/189120b5-c274-4e92-8657-8cd704806e1b/截屏2023-02-12_下午6.26.01.png" alt="截屏2023-02-12 下午6.26.01.png"></p><p>垃圾回收可以分段执行</p><p>问题：找到上一次标记的位置？</p><h3 id="_3-4-三色标记法" tabindex="-1"><a class="header-anchor" href="#_3-4-三色标记法" aria-hidden="true">#</a> 3.4 三色标记法</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/27fa3f10-f009-4330-8f20-9bfc96d9bc26/截屏2023-02-12_下午6.28.18.png" alt="截屏2023-02-12 下午6.28.18.png"></p><p>上次标记到的位置标记为灰色，下次从灰色位置执行</p><h3 id="_3-5-并发回收" tabindex="-1"><a class="header-anchor" href="#_3-5-并发回收" aria-hidden="true">#</a> 3.5 并发回收</h3><p>js在主线程执行，辅线程执行垃圾回收</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c7fdf760-2b47-4b43-9792-7c3cd622de7b/截屏2023-02-12_下午6.30.50.png" alt="截屏2023-02-12 下午6.30.50.png"></p>`,46),p=[c];function i(o,r){return s(),n("div",null,p)}const l=a(e,[["render",i],["__file","js垃圾回收机制.html.vue"]]);export{l as default};
