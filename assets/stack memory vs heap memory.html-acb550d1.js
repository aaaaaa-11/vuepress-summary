import{_ as e,M as r,p as a,q as o,R as t,t as l,N as n,a1 as c}from"./framework-5866ffd3.js";const s={},h=c('<h1 id="栈内存与堆内存" tabindex="-1"><a class="header-anchor" href="#栈内存与堆内存" aria-hidden="true">#</a> 栈内存与堆内存</h1><p>内存会被划分为栈、堆、静态存储区、程序代码取等</p><ul><li>栈空间较小，会存储一些函数运行时产生的临时变量等，发生溢出时会报错（StackOverFlowError）</li><li>堆相对较大，主要存放一些通过new出来的对象或malloc申请的内存空间</li><li>静态存储区在程序编译的时候就已经分配好，在整个程序运行过程中都存在，主要存放静态数据、全局数据和常量</li><li>程序代码区主要用于存放程序的二进制代码空间</li></ul><table><thead><tr><th></th><th>栈内存</th><th>堆内存</th></tr></thead><tbody><tr><td>内存分配与释放</td><td>分配的内存空间是连续的，编译器自动分配与回收</td><td>分配的内存空间是不连续的，手动申请和释放</td></tr><tr><td>成本</td><td>较小</td><td>较大</td></tr><tr><td>操作</td><td>简单</td><td>更难</td></tr><tr><td>访问时间</td><td>快</td><td>慢（因为不连续）</td></tr><tr><td>主要问题</td><td>内存不足</td><td>内存碎片</td></tr><tr><td>安全性</td><td>线程安全，存储的数据只能由所有者访问</td><td>非线程安全的，存储的数据对所有线程可见</td></tr><tr><td>灵活性</td><td>尺寸固定</td><td>可以调整大小</td></tr><tr><td>数据类型结构</td><td>线性</td><td>分层的</td></tr><tr><td>申请</td><td>从静态内存中分配</td><td>在链表中分配堆内存</td></tr><tr><td>尺寸</td><td>小于堆内存</td><td>大于栈内存</td></tr></tbody></table><p>解释：</p><p>栈内存：分配连续的内存空间，每次发生在函数调用时，其变量都会被分配栈内存，当函数调用结束时，释放变量内存，这些都是编译器自动执行。这种临时内存分配的方案，只有在函数运行时才能访问。当栈内存已满，会报错（StackOverFlowError）。这种内存申请和回收更快，且占用空间更小。</p><p>堆内存：在执行程序时，右程序员手动分配和释放的内存空间，当创建对象时，对象的引用信息会存放在堆内存中，对所有线程可访问，所以不如栈内存安全。如果程序员没有释放该内存，就会发生内存泄漏。如果堆内存已满，也会收到错误信息。与栈内存相比，堆内存的处理时间（访问时间）较慢，大小远大于栈内存，整个应用程序运行过程中堆内存都可以访问/存在。</p><p>栈内存更容易发生内存短缺的问题，而堆内存的主要问题是碎片化。</p>',8),i={href:"https://www.geeksforgeeks.org/stack-vs-heap-memory-allocation/",target:"_blank",rel:"noopener noreferrer"};function p(_,m){const d=r("ExternalLinkIcon");return a(),o("div",null,[h,t("p",null,[t("a",i,[l("参考"),n(d)])])])}const f=e(s,[["render",p],["__file","stack memory vs heap memory.html.vue"]]);export{f as default};
